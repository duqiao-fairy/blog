1. let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。

var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。

这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。

为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。

let不允许在相同作用域内，重复声明同一个变量。

块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。

let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”
```
// IIFE 写法
(function () {
  var tmp = ...;
  ...
}());
// 块级作用域写法
{
  let tmp = ...;
  ...
}
```

ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
在块级作用域之前加上do，使它变为do表达式。
```
let x = do {
  let t = f();
  t * t + 1;
};
````
上面代码中，变量x会得到整个块级作用域的返回值。
Let 不允许重复声明，es6的块级作用域

2. const声明一个只读的常量。一旦声明，常量的值就不能改变。对于const
来说，只声明不赋值，就会报错。

const的作用域与let命令相同：只在声明所在的块级作用域内有效。

3. var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。
```
window.a = 1;
a // 1 顶层对象属性

a = 2; 全局变量
window.a // 2 
```